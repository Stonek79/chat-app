# Правила и соглашения проекта

- **Архитектура**: Подходи к созданию архитектуры проекта и кода как старший разработчик. Всегда используй единый подход к архитектуре.

- **Типизация**: Строгая типизация с TypeScript, использование `any` запрещено. Наименования экспортируемых типов должны быть уникальными.

- **Стек**: Использовать последние возможности React 19 и Next.js 15, включая App Router и Server Components.

- **Импорты**:
    - Модули из директорий импортируются через `index.ts`.
    - Типы из папки `src/types` импортируются через алиас: `import { ... } from "@/types";`.
    - Импорты из `react` должны быть только именованными (`import { useState } from 'react'`). `import React from 'react'` не используется.

- **База данных**:
    - Схема Prisma


- **Безопасность и валидация**:
    - E2E-шифрование должно быть реализовано с использованием Web Crypto API.
    - Все входящие данные на уровне API должны проходить валидацию через Zod.

- **Качество кода**:
    - Если компонент превышает 200 строк, необходимо рассматривать варианты его декомпозиции.
    - Перед тем, как предложить решение, необходимо проверить, будет ли оно работать в контексте существующего кода.

- **Документация**:
    - Все ключевые компоненты, экспортируемые функции, хуки и API-эндпоинты должны быть задокументированы с использованием синтаксиса **TSDoc**.
    - Комментарии в коде должны объяснять *«почему»* (неочевидные решения, компромиссы), а не *«что»* делает код, если это следует из его названия и логики.

- **API и Типы данных (Schema-Driven)**:
    - Все схемы для валидации API (входящие запросы) и для DTO (исходящие ответы) должны быть определены с помощью **Zod** в директории `src/types`.
    - TypeScript-типы для API генерируются автоматически из Zod-схем с помощью `z.infer<typeof schema>`, что устраняет дублирование и рассинхронизацию типов.
    - Prisma Schema остается источником истины для моделей БД, а Zod-схемы — для публичных контрактов API.

- **Управление состоянием**:
    - **Глобальное состояние (Zustand)**:
        - Используется только для данных, необходимых в разных, не связанных иерархией компонентах (например, информация о пользователе, общий список чатов для сайдбара).
        - **Критически важно: Использовать паттерн селекторов (Selector Pattern)**. Для предотвращения "шторма перерисовок" (re-render storm) компоненты **обязаны** подписываться только на те части состояния, которые им необходимы. Это достигается использованием селекторов с функцией поверхностного сравнения (`shallow`).
            - **Правильно (DO)**: Хук или компонент подписывается на конкретные поля. Перерисовка происходит только при их изменении.
              ```typescript
              const { messages, participants } = useChatStore(
                state => ({ messages: state.activeChat.activeChatMessages, participants: state.activeChat.activeChatParticipants }),
                shallow
              );
              ```
            - **Неправильно (DON'T)**: Подписка на весь стор. Компонент будет перерисовываться при любом изменении в состоянии, даже не связанном с ним.
              ```typescript
              const store = useChatStore(); // Вызывает лишние ререндеры
              const messages = store.activeChat.activeChatMessages;
              ```
    - **Состояние фичи (React Context / кастомные хуки)** используется для данных, разделяемых в рамках одной крупной фичи (например, сообщения и участники внутри открытого чата).
    - **Локальное состояние (`useState`)** используется для всего остального (состояние полей ввода, видимость модальных окон).

- **Обработка ошибок**:
    - **Бэкенд**: Ошибки в API централизованно обрабатываются для отправки структурированных ответов (`{ success: false, error: '...' }`).
    - **Фронтенд**: Используется централизованный сервис уведомлений (`react-hot-toast`). Хуки (`useAuth`, `useChat`) возвращают состояние ошибки (`error`), которое компоненты используют для отображения inline-ошибок.
