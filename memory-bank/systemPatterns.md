# System Patterns and Architecture

Этот документ описывает архитектурные решения и паттерны, принятые в проекте.

## Архитектура

Проект построен на основе монорепозитория с отдельными модулями.

# Chat

1.  **Next.js Приложение**:
    - **Фреймворк**: Next.js 15 с **App Router**.
    - **Рендеринг**: Активное использование **серверных компонентов** для выборки данных и статического рендеринга, и **клиентских компонентов** для интерактивности (чаты, формы).
    - **API**: API-маршруты реализованы через **Route Handlers** в `src/app/api/`.

2.  **Выделенный Socket.IO Сервер**:
    - **Расположение**: `socket-server/`.
    - **Назначение**: Обработка всех real-time соединений и событий. Это решение принято для масштабируемости и разделения ответственности.
    - **Масштабирование**: Интеграция с **Redis Adapter** (`@socket.io/redis-adapter`) позволяет горизонтально масштабировать сокет-серверы.

# Packages
3.  **База данных и кэш**:
    - **БД**: **PostgreSQL** как основное хранилище данных.
    - **ORM**: **Prisma** для взаимодействия с базой данных.
    - **Кэш и Pub/Sub**: **Redis** используется для:
        - Кэширования часто запрашиваемых данных.
        - **Pub/Sub механизма** для связи между Next.js API и Socket.IO сервером. Например, когда API создает новый чат, оно публикует событие в Redis, а сокет-сервер, подписанный на него, уведомляет участников.

4.  **Core**:
    - Общее ядро монорепы, содержит типы, константы, схемы и мапперы для сущностей чата.

5.  **Общий серверный модуль (server-shared)**:
    - Содержит конфиги и модуль редиса.

6.  **Общий модуль сокетов (socket-shared)**:
    - Экспортирует клиент сокета, содердит константы сокет событий, типы и схемы для сокетов.

7.  **Модуль работы с медиа**:
    - Содержит загрузчики и оработчики медиа файлов приложения.

## Ключевые паттерны

- **Multi-file Prisma Schema**: Схема Prisma находится в директории `prisma/`. 
- **DTO (Data Transfer Object)**: Используются мапперы для преобразования моделей Prisma в `Client`-типы (например, `ClientChat`), чтобы отправлять на клиент только безопасные и необходимые данные.
- **RBAC (Role-Based Access Control) для Чатов**:
    - **Стандартный интерфейс**: В обычном UI (`/chat`) все пользователи, **включая администраторов**, видят и могут получить доступ только к тем чатам, участниками которых они являются. Это гарантирует, что администраторы не могут просматривать приватные чаты, к которым их не приглашали.
    - **Админ-панель**: Специализированный интерфейс (`/admin/dashboard`) предоставляет администраторам доступ к метаданным всех чатов в системе (список, участники). Однако, в соответствии с будущей реализацией E2E-шифрования, администраторы **не имеют доступа** к содержимому сообщений в приватных чатах.
- **Константы для событий**: Все имена событий Socket.IO вынесены в константы для избежания ошибок и централизованного управления.
- **Централизованные импорты**: Модули и типы экспортируются через `index.ts` файлы в своих директориях для более чистых импортов.
- **Schema-Driven Development с Zod**: **Zod** является **единственным источником правды (Single Source of Truth)** для всех DTO и моделей данных.
    - **Схемы Zod** определяют структуру, валидацию и сообщения об ошибках для данных, передаваемых между клиентом и сервером. Они находятся в директории `src/schemas`.
    - **Типы TypeScript** для этих данных автоматически выводятся (infer) из схем Zod с помощью `z.infer<typeof schema>`. Это исключает рассинхронизацию между валидацией и статическими типами.
- **Строгая политика импортов (Barrel Files)**: Для поддержания чистоты кода и предсказуемости, все импорты из основных директорий (`components`, `constants`, `hooks`, `lib`, `schemas`, `types` и т.д.) должны осуществляться через их верхнеуровневый `index.ts` (barrel file). Это правило принудительно проверяется ESLint (`no-restricted-imports`).
- **Запрет утверждений типа (`as`)**: Утверждения типа (например, `foo as Bar`) запрещены в кодовой базе приложения (`src/**/*.ts(x)`). Этот паттерн может скрывать ошибки типизации и приводить к ошибкам в рантайме. Вместо него следует использовать более безопасные альтернативы:
    - **Сужение типов (Type Guards)**: Функции, которые проверяют тип и возвращают `value is Type`.
    - **Парсинг с помощью Zod**: Валидация внешних данных и получение строго типизированного объекта.
    - В крайнем случае, можно использовать `@ts-ignore` с комментарием, объясняющим причину.
    Исключения допускаются только в конфигурационных файлах. Правило принудительно проверяется ESLint (`no-restricted-syntax` для `TSAsExpression`).
- **Необратимое удаление связанных данных (Hard Delete Pattern)**: При удалении основной сущности (например, сообщения) используется паттерн полного физического удаления, который гарантирует целостность данных:
    - **Атомарность**: Все операции выполняются внутри одной транзакции БД (`prisma.$transaction`).
    - **Разрыв связей**: Все дочерние сущности, которые ссылаются на удаляемую (например, ответы на сообщение), обновляются для удаления ссылки (`replyToId: null`).
    - **Удаление внешних ресурсов**: Связанные файлы (например, медиа в S3) удаляются до удаления записи в БД.
    - **Физическое удаление**: После успешного выполнения всех шагов основная запись удаляется из БД.

- **Якорная загрузка сообщений (`Anchor-Based Message Loading`)**: Для эффективной и предсказуемой загрузки истории сообщений используется "якорный" механизм.
    - **Определение якоря**: При открытии чата в качестве "якоря" используется `lastReadMessageId` (ID последнего прочитанного пользователем сообщения). Если его нет (новый чат), якорь отсутствует.
    - **API-запрос**: Клиент делает запрос к API с параметром `?anchorId=...`.
    - **Логика на сервере**: Бэкенд загружает "срез" сообщений вокруг указанного якоря (например, N/2 сообщений до и N/2 сообщений после). Если якорь не указан, загружается последняя страница сообщений.
    - **Преимущества**: Этот паттерн позволяет начинать просмотр истории с релевантного места, избегая загрузки большого количества ненужных сообщений и упрощая логику как на клиенте, так и на сервере.

- **Счетчик уникальных событий через Redis (`Unique Event Counting`)**: Для эффективного подсчета уникальных действий (например, просмотров сообщений в канале) без перегрузки основной БД.
    - **Действие на клиенте**: При событии (например, сообщение стало видимым) клиент отправляет запрос на специальный API-эндпоинт (`PATCH /api/messages/:id/view`).
    - **Логика на сервере (Redis)**: Сервер пытается добавить уникальный ключ (например, `view:{messageId}:{userId}`) в Redis Set. `SADD` - атомарная операция, которая вернет `1`, если элемент был добавлен (просмотр уникальный), и `0`, если он уже существовал.
    - **Логика на сервере (БД)**: Только если Redis `SADD` вернул `1`, сервер инкрементирует счетчик в основной базе данных (`viewCount` в таблице `Message`).
    - **Преимущества**: Снижает нагрузку на запись в основную БД в тысячи раз для популярных постов/каналов. Redis идеально подходит для таких быстрых атомарных операций.

## Архитектура Push-уведомлений (Web Push API)

Для доставки уведомлений, когда приложение неактивно, используется следующий механизм:

1.  **Service Worker**: Фоновый скрипт, генерируемый `next-pwa`, который слушает `push` события от Push-сервисов (Google, Apple, etc).
2.  **Подписка клиента**:
    - Клиент запрашивает у пользователя разрешение (`Notification.requestPermission()`).
    - При согласии браузер выдает объект `PushSubscription`.
    - Этот объект отправляется и сохраняется на бэкенде в специальной таблице `PushSubscription`, связанной с пользователем.
3.  **Отправка с бэкенда**:
    - Когда происходит событие (новое сообщение), `socket-server` или API находят подписки целевых пользователей.
    - С помощью библиотеки `web-push` бэкенд отправляет зашифрованное уведомление на endpoint из `PushSubscription`.
4.  **Отображение**: Service Worker на клиенте получает push-событие, расшифровывает payload и показывает системное уведомление через `self.registration.showNotification()`.
