# System Patterns and Architecture

Этот документ описывает архитектурные решения и паттерны, принятые в проекте.

## Архитектура

Проект построен на основе монорепозитория с отдельными модулями.

# Chat

1.  **Next.js Приложение**:
    - **Фреймворк**: Next.js 15 с **App Router**.
    - **Рендеринг**: Активное использование **серверных компонентов** для выборки данных и статического рендеринга, и **клиентских компонентов** для интерактивности (чаты, формы).
    - **API**: API-маршруты реализованы через **Route Handlers** в `src/app/api/`.

2.  **Выделенный Socket.IO Сервер**:
    - **Расположение**: `socket-server/`.
    - **Назначение**: Обработка всех real-time соединений и событий. Это решение принято для масштабируемости и разделения ответственности.
    - **Масштабирование**: Интеграция с **Redis Adapter** (`@socket.io/redis-adapter`) позволяет горизонтально масштабировать сокет-серверы.

# Packages
3.  **База данных и кэш**:
    - **БД**: **PostgreSQL** как основное хранилище данных.
    - **ORM**: **Prisma** для взаимодействия с базой данных.
    - **Кэш и Pub/Sub**: **Redis** используется для:
        - Кэширования часто запрашиваемых данных.
        - **Pub/Sub механизма** для связи между Next.js API и Socket.IO сервером. Например, когда API создает новый чат, оно публикует событие в Redis, а сокет-сервер, подписанный на него, уведомляет участников.

4.  **Core**:
    - Общее ядро монорепы, содержит типы, константы, схемы и мапперы для сущностей чата.

5.  **Общий серверный модуль (server-shared)**:
    - Содержит конфиги и модуль редиса.

6.  **Общий модуль сокетов (socket-shared)**:
    - Экспортирует клиент сокета, содердит константы сокет событий, типы и схемы для сокетов.

7.  **Модуль работы с медиа**:
    - Содержит загрузчики и оработчики медиа файлов приложения.

## Ключевые паттерны

- **Multi-file Prisma Schema**: Схема Prisma находится в директории `prisma/`. 
- **DTO (Data Transfer Object)**: Используются мапперы для преобразования моделей Prisma в `Client`-типы (например, `ClientChat`), чтобы отправлять на клиент только безопасные и необходимые данные.
- **RBAC (Role-Based Access Control) для Чатов**:
    - **Стандартный интерфейс**: В обычном UI (`/chat`) все пользователи, **включая администраторов**, видят и могут получить доступ только к тем чатам, участниками которых они являются. Это гарантирует, что администраторы не могут просматривать приватные чаты, к которым их не приглашали.
    - **Админ-панель**: Специализированный интерфейс (`/admin/dashboard`) предоставляет администраторам доступ к метаданным всех чатов в системе (список, участники). Однако, в соответствии с будущей реализацией E2E-шифрования, администраторы **не имеют доступа** к содержимому сообщений в приватных чатах.
- **Константы для событий**: Все имена событий Socket.IO вынесены в константы для избежания ошибок и централизованного управления.
- **Централизованные импорты**: Модули и типы экспортируются через `index.ts` файлы в своих директориях для более чистых импортов.
- **Schema-Driven Development с Zod**: **Zod** является **единственным источником правды (Single Source of Truth)** для всех DTO и моделей данных.
    - **Схемы Zod** определяют структуру, валидацию и сообщения об ошибках для данных, передаваемых между клиентом и сервером. Они находятся в директории `src/schemas`.
    - **Типы TypeScript** для этих данных автоматически выводятся (infer) из схем Zod с помощью `z.infer<typeof schema>`. Это исключает рассинхронизацию между валидацией и статическими типами.
- **Строгая политика импортов (Barrel Files)**: Для поддержания чистоты кода и предсказуемости, все импорты из основных директорий (`components`, `constants`, `hooks`, `lib`, `schemas`, `types` и т.д.) должны осуществляться через их верхнеуровневый `index.ts` (barrel file). Это правило принудительно проверяется ESLint (`no-restricted-imports`).
- **Запрет утверждений типа (`as`)**: Утверждения типа (например, `foo as Bar`) запрещены в кодовой базе приложения (`src/**/*.ts(x)`). Этот паттерн может скрывать ошибки типизации и приводить к ошибкам в рантайме. Вместо него следует использовать более безопасные альтернативы:
    - **Сужение типов (Type Guards)**: Функции, которые проверяют тип и возвращают `value is Type`.
    - **Парсинг с помощью Zod**: Валидация внешних данных и получение строго типизированного объекта.
    - В крайнем случае, можно использовать `@ts-ignore` с комментарием, объясняющим причину.
    Исключения допускаются только в конфигурационных файлах. Правило принудительно проверяется ESLint (`no-restricted-syntax` для `TSAsExpression`).
- **Необратимое удаление связанных данных (Hard Delete Pattern)**: При удалении основной сущности (например, сообщения) используется паттерн полного физического удаления, который гарантирует целостность данных:
    - **Атомарность**: Все операции выполняются внутри одной транзакции БД (`prisma.$transaction`).
    - **Разрыв связей**: Все дочерние сущности, которые ссылаются на удаляемую (например, ответы на сообщение), обновляются для удаления ссылки (`replyToId: null`).
    - **Удаление внешних ресурсов**: Связанные файлы (например, медиа в S3) удаляются до удаления записи в БД.
    - **Физическое удаление**: После успешного выполнения всех шагов основная запись удаляется из БД.

- **Якорная загрузка сообщений (`Anchor-Based Message Loading`)**: Для эффективной и предсказуемой загрузки истории сообщений используется "якорный" механизм.
    - **Определение якоря**: При открытии чата в качестве "якоря" используется `lastReadMessageId` (ID последнего прочитанного пользователем сообщения). Если его нет (новый чат), якорь отсутствует.
    - **API-запрос**: Клиент делает запрос к API с параметром `?anchorId=...`.
    - **Логика на сервере**: Бэкенд загружает "срез" сообщений вокруг указанного якоря (например, N/2 сообщений до и N/2 сообщений после). Если якорь не указан, загружается последняя страница сообщений.
    - **Преимущества**: Этот паттерн позволяет начинать просмотр истории с релевантного места, избегая загрузки большого количества ненужных сообщений и упрощая логику как на клиенте, так и на сервере.

- **Счетчик уникальных событий через Redis (`Unique Event Counting`)**: Для эффективного подсчета уникальных действий (например, просмотров сообщений в канале) без перегрузки основной БД.
    - **Действие на клиенте**: При событии (например, сообщение стало видимым) клиент отправляет запрос на специальный API-эндпоинт (`PATCH /api/messages/:id/view`).
    - **Логика на сервере (Redis)**: Сервер пытается добавить уникальный ключ (например, `view:{messageId}:{userId}`) в Redis Set. `SADD` - атомарная операция, которая вернет `1`, если элемент был добавлен (просмотр уникальный), и `0`, если он уже существовал.
    - **Логика на сервере (БД)**: Только если Redis `SADD` вернул `1`, сервер инкрементирует счетчик в основной базе данных (`viewCount` в таблице `Message`).
    - **Преимущества**: Снижает нагрузку на запись в основную БД в тысячи раз для популярных постов/каналов. Redis идеально подходит для таких быстрых атомарных операций.

## Архитектура Push-уведомлений (Web Push API)

Для доставки уведомлений, когда приложение неактивно, используется следующий механизм:

1.  **Service Worker**: Фоновый скрипт, генерируемый `next-pwa`, который слушает `push` события от Push-сервисов (Google, Apple, etc).
2.  **Подписка клиента**:
    - Клиент запрашивает у пользователя разрешение (`Notification.requestPermission()`).
    - При согласии браузер выдает объект `PushSubscription`.
    - Этот объект отправляется и сохраняется на бэкенде в специальной таблице `PushSubscription`, связанной с пользователем.
3.  **Отправка с бэкенда**:
    - Когда происходит событие (новое сообщение), `socket-server` или API находят подписки целевых пользователей.
    - С помощью библиотеки `web-push` бэкенд отправляет зашифрованное уведомление на endpoint из `PushSubscription`.
4.  **Отображение**: Service Worker на клиенте получает push-событие, расшифровывает payload и показывает системное уведомление через `self.registration.showNotification()`.

## Структура каталогов (Детализированная)
//TODO На данный момент неактуальна, требуется утонение с учетом новой структуры на основе монорепы!
```
/chat-app
├── memory-bank/            # <--- Контекст, прогресс и правила проекта
├── prisma/                 # Prisma ORM
│   ├── schema/             # Мультифайловая схема Prisma (User.prisma, Chat.prisma и т.д.)
│   └── migrations/         # Миграции базы данных
├── public/                 # Статические ассеты (иконки для PWA)
├── socket-server/          # Выделенный Socket.IO сервер на TypeScript
│   ├── src/
│   │   ├── constants/      # Константы (имена каналов Redis)
│   │   ├── middlewares/    # Middleware для Socket.IO (authMiddleware.ts)
│   │   └── server.ts       # Основной файл сервера
│   └── (node_modules, tsconfig.json, package.json)
└── src/                    # Исходный код Next.js приложения
    ├── app/                # App Router: Роуты и страницы
    │   ├── api/            # API эндпоинты (Route Handlers)
    │   │   ├── auth/       # /api/auth/*: login, logout, me, register, confirm
    │   │   ├── chats/      # /api/chats/*: create, /, [chatId]
    │   │   └── messages/   # /api/messages/*: [messageId]
    │   ├── chat/[chatId]/  # Динамическая страница чата
    │   ├── admin/dashboard/# Страница админ-панели
    │   ├── (login, register, profile, confirm) # Другие страницы
    │   └── layout.tsx      # Главный layout приложения
    ├── components/         # Общие клиентские UI-компоненты
    │   ├── auth/           # Компоненты для аутентификации (LoginForm, RegisterForm)
    │   │   ├── common/     # Общие компоненты для форм (кнопки, ссылки)
    │   │   └── fields/     # Поля ввода (EmailField, PasswordField)
    │   ├── chat/           # Компоненты для чата (ChatContent, MessageInput)
    │   ├── layout/         # Компоненты макета (Sidebar, ErrorBoundary)
    │   │   └── sidebar/    # Внутренние компоненты сайдбара
    │   ├── message/        # Компонент MessageBubble
    │   ├── profile/        # Компонент UserProfileEditForm
    │   └── common/         # Общие компоненты (модальные окна)
    ├── constants/          # Константы приложения (apiRoutes, socketEvents, etc.)
    ├── contexts/           # React Contexts (AuthContext)
    ├── hooks/              # Кастомные React хуки (useAuth, useChat, etc.)
    ├── lib/                # Библиотеки и утилиты
    │   ├── api/            # Утилиты для API (apiErrorHandler)
    │   ├── auth/           # Логика сессий JWT
    │   ├── crypto/         # E2E-шифрование
    │   ├── fetch/          # Функции для получения данных
    │   ├── mappers/        # Мапперы (DTO) для преобразования Prisma моделей
    │   ├── prisma/         # Инициализация Prisma Client
    │   ├── redis/          # Инициализация Redis Client
    │   └── socket/         # Клиентская обертка для Socket.IO
    ├── providers/          # Провайдеры (AuthProvider)
    ├── schemas/            # Схемы Zod - единый источник правды для моделей данных
    ├── store/              # Стейт-менеджер (Zustand: chatStore)
    ├── types/              # Глобальные типы TypeScript, выводимые из схем Zod
    │   ├── auth/           # Типы для аутентификации (выведены из authSchemas)
    │   ├── chat/           # Типы для чатов (выведены из chatSchemas)
    │   ├── message/        # Типы для сообщений (выведены из messageSchemas)
    │   ├── sockets/        # Типы для событий Socket.IO
    │   └── user/           # Типы для пользователя
    └── utils/              # Вспомогательные утилиты
``` 