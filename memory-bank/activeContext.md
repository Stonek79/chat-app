# Активный план доработок (Текущий Спринт)

**Процесс работы:** Этот документ содержит детальный план для *текущего* этапа. Перед началом нового этапа мы "расшиваем" его высокоуровневые задачи из `progress.md` и помещаем детальный план сюда. После завершения всех задач, мы обновляем `progress.md` и планируем следующий этап.

---

### **Текущий Этап: 3. Внедрение Schema-Driven Development (Zod)**
**Цель:** Создать единый источник правды для DTO и схем валидации API, устранить рассинхронизацию типов.

#### **Часть 1: Типы и схемы для Чатов**

1.  **[ ] Создать файл для Zod-схем чата:**
    - **Действие:** Создать новый файл `src/types/chat/chatSchemas.ts`.

2.  **[ ] Определить Zod-схемы для DTO чата:**
    - **Действие:** В `src/types/chat/chatSchemas.ts` определить и экспортировать следующие схемы:
        - `clientChatParticipantSchema` (на основе `ClientChatParticipant`)
        - `chatLastMessageSchema` (на основе `ChatLastMessage`)
        - `clientChatSchema` (на основе `ClientChat`, используя две предыдущие схемы)
    - **TSDoc:** Добавить TSDoc-комментарии к каждой схеме.

3.  **[ ] Трансформировать TypeScript типы чата:**
    - **Действие:** В файле `src/types/chat/chatTypes.ts`:
        - Удалить ручные `interface` `ClientChatParticipant`, `ChatLastMessage`, `ClientChat`.
        - Импортировать схемы из `chatSchemas.ts`.
        - Создать и экспортировать типы через `z.infer`:
            ```typescript
            export type ClientChatParticipant = z.infer<typeof clientChatParticipantSchema>;
            export type ChatLastMessage = z.infer<typeof chatLastMessageSchema>;
            export type ClientChat = z.infer<typeof clientChatSchema>;
            ```

4.  **[ ] Обновить маппер чатов:**
    - **Действие:** В файле `src/lib/mappers/chatMappers.ts` в функции `mapPrismaChatToClientChat`:
        - Импортировать `clientChatSchema`.
        - Перед `return` добавить валидацию: `return clientChatSchema.parse(clientChat);`

#### **Часть 2: Типы и схемы для Аутентификации**

5.  **[x] Создать файл для Zod-схем аутентификации:**
    - **Действие:** Создан файл `src/schemas/authSchemas.ts`.

6.  **[x] Определить Zod-схемы для API аутентификации:**
    - **Действие:** В `src/schemas/authSchemas.ts` определены и экспортированы схемы `registerSchema`, `loginSchema` и `userResponseSchema`.

7.  **[x] Трансформировать TypeScript типы аутентификации:**
    - **Действие:** В файле `src/types/auth/authTypes.ts` удалить дублирующиеся типы и заменить их на `z.infer` из `src/schemas/authSchemas.ts`.

8.  **[x] Централизовать валидацию API:**
    - **Действие:** В `src/app/api/auth/register/route.ts` и `src/app/api/auth/login/route.ts` используются импортированные схемы для валидации.

9.  **[x] Исправить конфигурацию ESLint для корректной работы в IDE.**

10. **[x] Устранить небезопасные приведения типов (`as`) и использование `any`.**

11. **[x] Улучшить обработку ошибок в `AuthProvider` для предотвращения "зависших" состояний.**

---

### Этап 2: Внедрение стратегии обработки ошибок (Frontend)
- **Цель:** Обеспечить централизованную и понятную пользователю обработку ошибок.
- **Задачи:**
    1.  [x] Установить зависимость: `npm install react-hot-toast`.
    2.  [x] Добавить `<Toaster />` в корневой `src/app/layout.tsx`.
    3.  [x] Модифицировать хуки, работающие с API (`useAuth`, `useChat`): добавить `error` в состояние, возвращать его и вызывать `toast.error()` в `catch`.
    4.  [x] Обновить UI-компоненты (`LoginForm`) для отображения `error` из хуков.

---

### Этап 3: База данных и API для Push-уведомлений
- **Цель:** Подготовить бэкенд для приема подписок и отправки уведомлений.
- **Задачи:**
    1.  [ ] Добавить в `prisma/schema/` новую модель `PushSubscription.prisma`, связанную с `User`.
    2.  [ ] Создать и применить миграцию для новой таблицы.
    3.  [ ] Реализовать API `POST /api/push/subscribe` и `POST /api/push/unsubscribe`.
    4.  [ ] Установить `npm install web-push` и сгенерировать VAPID ключи.

---

### Этап 4: Реализация Push-уведомлений (Клиент и Service Worker)
- **Цель:** Реализовать полный цикл работы Push-уведомлений на клиенте.
- **Задачи:**
    1.  [ ] В UI (настройки профиля) добавить кнопку "Включить уведомления".
    2.  [ ] Написать клиентскую логику для запроса разрешений и отправки `PushSubscription` на бэкенд.
    3.  [ ] В `next.config.mjs` настроить `next-pwa` для инъекции кастомного кода в Service Worker.
    4.  [ ] В Service Worker добавить обработчик `push` для отображения уведомлений.
    5.  [ ] В `socket-server` интегрировать логику отправки push-сообщений через `web-push` при получении нового сообщения.
    6.  [ ] Реализовать `Badging API` для обновления иконки PWA.

---

### Этап 5: Внедрение глобального стейт-менеджера (Zustand)
- **Цель:** Синхронизировать состояние между независимыми частями UI (сайдбар, основное окно).
- **Задачи:**
    1.  [ ] Доработать `src/store/chatStore.ts` (состояние `chats: ClientChat[]` и `unreadCounts`, экшены).
    2.  [ ] Реализовать первоначальную загрузку чатов с сервера и инициализацию стора.
    3.  [ ] В сайдбаре (`ChatListSection.tsx`) использовать `useChatStore` для отображения списка чатов.
    4.  [ ] Настроить WebSocket-слушатель для обновления стора при получении новых сообщений или чатов.

## Текущий фокус: Этапы 4 и 5 (Чаты и Сообщения)

### [~] Интеграция Socket.IO, Redis и API

- **[~] Межсерверное взаимодействие через Redis Pub/Sub:**
    - [x] `socket-server` подписывается на Redis-канал для уведомлений.
    - [~] Next.js API (`/api/chats/create`) публикует событие `NEW_CHAT` в Redis-канал после успешного создания чата в БД.
    - [ ] Провести сквозное тестирование: API-запрос -> публикация в Redis -> получение в `socket-server`.
- **[~] Доставка событий клиентам через Socket.IO:**
    - [x] `socket-server` при получении события из Redis находит нужных пользователей.
    - [~] `socket-server` отправляет событие `SERVER_EVENT_CHAT_CREATED` с данными чата (`ClientChat`) в личную комнату каждого участника.
    - [ ] На клиенте в `useChat` реализовать подписку на `SERVER_EVENT_CHAT_CREATED` и обновление глобального стейта (Zustand) со списком чатов.

### [~] Реализация API для управления чатами

- **[x] Создание чата (`POST /api/chats/create`):**
    - [x] Аутентификация пользователя через middleware.
    - [x] Валидация входных данных (Zod): `name`, `isGroup`, `participantIds`.
    - [x] Проверка на существование дублирующего приватного чата.
    - [x] Создание записи `Chat` и `ChatParticipant` в рамках одной Prisma-транзакции.
    - [x] Маппинг результата в `ClientChat` перед отправкой ответа.
    - [x] Публикация события в Redis (см. пункт выше).
- **[x] Получение списка чатов (`GET /api/chats`):**
    - [x] Реализован API эндпоинт.
    - [x] Аутентификация пользователя.
    - [x] Логика получения списка чатов, где пользователь является участником.
    - [x] Включены в запрос данные о последнем сообщении и участниках (`_count` для непрочитанных).
    - [x] Чаты отсортированы по времени последнего сообщения.
    - [x] Реализован маппинг в `ClientChat[]`.
- **[~] Получение истории сообщений (`GET /api/chats/[chatId]`):**
    - [x] Реализован API эндпоинт `GET /api/chats/[chatId]`.
    - [x] Аутентификация и проверка, что пользователь является участником чата.
    - [~] Реализована загрузка первой порции сообщений.
    - [ ] Реализовать отдельный эндпоинт с полной, курсорной пагинацией (`GET /api/chats/[chatId]/messages`).
    - [x] Реализован маппинг в `ClientChat` с вложенными сообщениями.

### [~] Обработка сообщений в реальном времени

- **[~] Отправка сообщения (`CLIENT_EVENT_SEND_MESSAGE` на `socket-server`):**
    - [x] Валидация входящего payload (`chatId`, `content`).
    - [~] Сохранение сообщения в БД (модель `Message`) через Prisma.
    - [ ] Установить `Message.status = 'sent'`.
    - [ ] Обновить поле `updatedAt` у связанного чата `Chat`.
    - [~] Получить `id` и `createdAt` созданного сообщения из БД.
    - [~] Отправить `ack` клиенту с `{ success: true, messageId, createdAt }`.
    - [ ] Передать полное сообщение (`SocketMessagePayload`) всем участникам чата через событие `SERVER_EVENT_RECEIVE_MESSAGE`.
- **[~] Клиентская логика (`useChat.ts`):**
    - [ ] Оптимистичное обновление UI при отправке сообщения.
    - [x] Обработка `ack` от сервера для обновления статуса сообщения с "sending" на "sent" и присвоения ему `id` из БД.
    - [x] Обработка входящего события `SERVER_EVENT_RECEIVE_MESSAGE` для добавления нового сообщения в чат.

### [ ] Завершение этапа Аутентификации (Этап 3)
- **[ ] Интеграция с почтовым сервисом:**
    - [ ] Установить `nodemailer` и настроить транспорт (Mailtrap для dev, Sendgrid/Resend для prod).
    - [ ] В API `/api/auth/register` после создания пользователя генерировать токен подтверждения и отправлять email.
    - [ ] Реализовать API `/api/auth/confirm/[token]` для верификации токена и активации пользователя.

## Ближайшие цели (после текущего фокуса)

- **[ ] Этап 6: Продвинутая функциональность сообщений**
- **[ ] Этап 7: UI/UX и Компоненты** 